enum <uint> VertexAttributeName
{
    POSITION            = 0xD2F7D823,
    NORMAL              = 0x36F5E414,
    TESSELATION_NORMAL  = 0x3E7F6149,
    TANGENT             = 0xF1ED11C3,
    BINORMAL            = 0x64A86F01,
    SKIN_WEIGHTS        = 0x48E691C0,
    SKIN_INDICES        = 0x5156D8D3,
    COLOR1              = 0x7E7DD623,
    COLOR2              = 0x733EF0FA,
    TEXCOORD1           = 0x8317902A,
    TEXCOORD2           = 0x8E54B6F3,
    TEXCOORD3           = 0x8A95AB44,
    TEXCOORD4           = 0x94D2FB41
};

enum <byte> VertexAttributeType
{
    FLOAT1 = 0,
    FLOAT2 = 1,
    FLOAT3 = 2,
    FLOAT4 = 3,
    R8G8B8A8_UNORM_0 = 4,
    R8G8B8A8_UNORM_1 = 5,
    R8G8B8A8_UNORM_2 = 6,
    R8G8B8A8_UNORM_3 = 7,
    R8G8B8A8_UNORM_4 = 13,
    R8G8B8A8_UNORM_5 = 22,
    R8G8B8A8_UINT_0 = 8,
    R8G8B8A8_UINT_1 = 23,
    R16G16_SINT = 9,
    R16G16B16A16_SINT = 10,
    R16G16B16A16_UINT_0 = 11,
    R16G16B16A16_UINT_1 = 24,
    R32G32B32A32_UINT = 12,
    R16G16_SNORM_0 = 14,
    R16G16_SNORM_1 = 25,
    R16G16B16A16_SNORM_0 = 15,
    R16G16B16A16_SNORM_1 = 26,
    R16G16_UNORM = 16,
    R16G16B16A16_UNORM = 17,
    R10G10B10A2_UINT = 18,
    R10G10B10A2_UNORM_0 = 19,
    R10G10B10A2_UNORM_1 = 20
};

local VertexAttributeType gTr10ToTr11VertexAttributeTypeMapping[21];
gTr10ToTr11VertexAttributeTypeMapping[0] = FLOAT1;
gTr10ToTr11VertexAttributeTypeMapping[1] = FLOAT2;
gTr10ToTr11VertexAttributeTypeMapping[2] = FLOAT3;
gTr10ToTr11VertexAttributeTypeMapping[3] = FLOAT4;
gTr10ToTr11VertexAttributeTypeMapping[4] = R8G8B8A8_UNORM_0;
gTr10ToTr11VertexAttributeTypeMapping[5] = R8G8B8A8_UNORM_1;
gTr10ToTr11VertexAttributeTypeMapping[6] = R8G8B8A8_UNORM_2;
gTr10ToTr11VertexAttributeTypeMapping[7] = R8G8B8A8_UNORM_3;
gTr10ToTr11VertexAttributeTypeMapping[8] = R8G8B8A8_UINT_0;
gTr10ToTr11VertexAttributeTypeMapping[9] = R16G16_SINT;
gTr10ToTr11VertexAttributeTypeMapping[10] = R16G16B16A16_SINT;
gTr10ToTr11VertexAttributeTypeMapping[11] = R8G8B8A8_UNORM_4;
gTr10ToTr11VertexAttributeTypeMapping[12] = R16G16_SNORM_0;
gTr10ToTr11VertexAttributeTypeMapping[13] = R16G16B16A16_SNORM_0;
gTr10ToTr11VertexAttributeTypeMapping[14] = R16G16_UNORM;
gTr10ToTr11VertexAttributeTypeMapping[15] = R16G16B16A16_UNORM;
gTr10ToTr11VertexAttributeTypeMapping[16] = R10G10B10A2_UINT;
gTr10ToTr11VertexAttributeTypeMapping[17] = R10G10B10A2_UNORM_0;
gTr10ToTr11VertexAttributeTypeMapping[19] = R16G16_SNORM_1;
gTr10ToTr11VertexAttributeTypeMapping[20] = R16G16B16A16_SNORM_1;

typedef struct
{
    VertexAttributeName name;
    short offset <format=hex>;
    byte type;
    byte vertexBufferIdx;
    
    local VertexAttributeType unifiedType;
    switch (TR_VERSION)
    {
        case 10:
            unifiedType = gTr10ToTr11VertexAttributeTypeMapping[type];
            break;
        
        case 11:
            unifiedType = type;
            break;
    }
} VertexFormatAttribute <read=EnumToString(name), optimize=false>;

typedef struct
{
    quad hash <format=hex>;
    ushort numAttributes;
    ubyte vertexSizes[2] <format=hex>;
    FSkip(4);
    VertexFormatAttribute attributes[numAttributes];
} VertexFormat;

typedef struct (VertexAttributeName name, VertexAttributeType type)
{
    local VertexAttributeName name_ = name;
    switch (type)
    {
        case FLOAT1:
            float x;
            break;
        
        case FLOAT2:
            float x, y;
            break;
        
        case FLOAT3:
            float x, y, z;
            break;
        
        case FLOAT4:
            float x, y, z, w;
            break;
        
        case R8G8B8A8_UNORM_0:
        case R8G8B8A8_UNORM_1:
        case R8G8B8A8_UNORM_2:
        case R8G8B8A8_UNORM_3:
        case R8G8B8A8_UNORM_4:
        case R8G8B8A8_UNORM_5:
            ubyte x <read=(this / 255.0)>;
            ubyte y <read=(this / 255.0)>;
            ubyte z <read=(this / 255.0)>;
            ubyte w <read=(this / 255.0)>;
            break;
        
        case R8G8B8A8_UINT_0:
        case R8G8B8A8_UINT_1:
            ubyte x, y, z, w;
            break;
        
        case R16G16_SINT:
            short x, y;
            break;
        
        case R16G16B16A16_SINT:
            short x, y, z, w;
            break;
        
        case R16G16B16A16_UINT_0:
        case R16G16B16A16_UINT_1:
            ushort x, y, z, w;
            break;
        
        case R32G32B32A32_UINT:
            uint x, y, z, w;
            break;
        
        case R16G16_SNORM_0:
        case R16G16_SNORM_1:
            short x <read=(this / 32768.0)>;
            short y <read=(this / 32768.0)>;
            break;
        
        case R16G16B16A16_SNORM_0:
        case R16G16B16A16_SNORM_1:
            short x <read=(this / 32768.0)>;
            short y <read=(this / 32768.0)>;
            short z <read=(this / 32768.0)>;
            short w <read=(this / 32768.0)>;
            break;
        
        case R16G16_UNORM:
            ushort x <read=(this / 65535.0)>;
            ushort y <read=(this / 65535.0)>;
            break;
        
        case R16G16B16A16_UNORM:
            ushort x <read=(this / 65535.0)>;
            ushort y <read=(this / 65535.0)>;
            ushort z <read=(this / 65535.0)>;
            ushort w <read=(this / 65535.0)>;
            break;
        
        case R10G10B10A2_UINT:
            uint x : 10;
            uint y : 10;
            uint z : 10;
            uint w : 2;
            break;
        
        case R10G10B10A2_UNORM_0:
        case R10G10B10A2_UNORM_1:
            uint x : 10 <read=(this / 1023.0)>;
            uint y : 10 <read=(this / 1023.0)>;
            uint z : 10 <read=(this / 1023.0)>;
            uint w : 2  <read=(this / 3.0)>;
            break;
    }
} VertexAttribute <read=EnumToString(name_)>;

void MakeVertexAttributes(VertexFormat& format)
{
    local int vertexPos = FTell();
    local int i;
    for (i = 0; i < format.numAttributes; i++)
    {
        if (format.attributes[i].vertexBufferIdx != gCurrentVertexBufferIndex)
            continue;
        
        FSeek(vertexPos + format.attributes[i].offset);
        VertexAttribute attr(format.attributes[i].name, format.attributes[i].unifiedType);
    }
    FSeek(vertexPos + format.vertexSizes[gCurrentVertexBufferIndex]);
}

typedef struct
{
    MakeVertexAttributes(parentof(parentof(this)).vertexFormat);
} Vertex <optimize=true, style=sData>;

typedef struct
{
    uint numEntries : 8;
    uint startIndex : 24;
} BlendShapeSegment <size=4>;

typedef struct (float scale)
{
    local float scale_ = scale;
    uint x : 10 <read=((this / 1023.0 * 2 - 1) * parentof(this).scale_)>;
    uint y : 10 <read=((this / 1023.0 * 2 - 1) * parentof(this).scale_)>;
    uint z : 10 <read=((this / 1023.0 * 2 - 1) * parentof(this).scale_)>;
} BlendShapeVertexOffset <size=4, optimize=true>;

typedef struct
{
    
    int numBlendShapes;
    int numVertexOffsets;
    int field_8;
    int positionsOffset <format=hex>;
    int normalsOffset <format=hex>;
    int colorsOffset <format=hex>;
    int segmentsOffset <format=hex>;
    int vertexIndicesOffset <format=hex>;
    quad blendShapeBitmaskPtr <format=hex>;
    quad blendShapeDataPtr <format=hex>;
    if (TR_VERSION == 11)
    {
        quad blendShapeSrvsPtr <format=hex>;
    }
    
    local int basePos = startof(parentof(parentof(this)));
    
    FSeek(basePos + blendShapeBitmaskPtr);
    uint supportedBlendShapeBitmasks[(parentof(parentof(this)).header.numBlendShapes + 0x1F) >> 5] <format=hex>;
    
    if (numBlendShapes == 0)
    {
        if (TR_VERSION == 11)
            FAlign(0x20);
        
        return;
    }
    
    FSeek(basePos + segmentsOffset);
    local int numVertices = TR_VERSION == 10 ? parentof(parentof(this)).meshes[gCurrentMeshIndex].numVertices
                                             : parentof(parentof(this)).meshHeaders[gCurrentMeshIndex].numVertices;
    BlendShapeSegment segments[((numVertices + 0x3F) >> 6) * numBlendShapes];
    
    FSeek(basePos + positionsOffset);
    BlendShapeVertexOffset positionOffsets(8)[numVertexOffsets];
    
    FSeek(basePos + normalsOffset);
    BlendShapeVertexOffset normalOffsets(2)[numVertexOffsets];
    
    FSeek(basePos + colorsOffset);
    BlendShapeVertexOffset colorOffsets(1)[numVertexOffsets];
    
    FSeek(basePos + vertexIndicesOffset);
    ubyte vertexIndices[numVertexOffsets];
    
    if (TR_VERSION == 11)
        FAlign(0x20);
} BlendShapes;
